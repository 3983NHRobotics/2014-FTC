#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S2,     HTIRS2L,        sensorI2CCustom)
#pragma config(Sensor, S3,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S4,     US1,            sensorSONAR)
#pragma config(Motor,  motorA,          motorAutoScore, tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motorLeft,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorRight,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorArm,      tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorWinch,    tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servoUSSeeker,        tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-gyro.h"

void turnTowardsRobot();
void turnTowardsCenter();
void moveForward(int mtime, int mpower);
void moveBackward(int mtime, int mpower);
void pushOffRamp();

bool turnedLeft = false;
bool turnedRight = false;
bool searching = true;
bool searchingForBot = false;
bool koth = true;
bool goToEnd = true;
bool irOnLeft = false;
int roundTime = 0;
int timeToEnd = 3500;
int kothAttackDistance = 80; //distance in cm (ultrasonic sensor)
int irFindVal = 150; //edit this to match the ultrasonic sensor read value for the correct distance
int sizeOfFile = 400;
int accelTurnMax = 20;
int accelTurnMin = -20;
int USScanVal = 0;
string sTextLines[8];
string fileName = "IRvals.txt";
string irvalres = "";
float rotSpeed = 0;
float heading = 92;

const tMUXSensor HTGYRO = msensor_S3_3; //Gyro Sensor

task main() {

	servo[servoUSSeeker] = 92;
	HTGYROstartCal(HTGYRO);



	USScanVal = 92;

	while (true) {
		//SCAN LEFT==========================
		//while (USScanVal <= 68) {
		while(true) {

			servo[servoUSSeeker] = ServoValue[servoUSSeeker] + 5;
			USScanVal += 5;
			wait1Msec(100);

			if (SensorValue[US1] < kothAttackDistance && nPgmTime < 27000) { //if something is in range AND program time is less than 27 seconds
				PlaySound(soundFastUpwardTones);
				searchingForBot = true;
				turnedLeft = true;
				turnedRight = false;
				turnTowardsRobot();
				pushOffRamp();
				turnTowardsCenter();
			}
			if (USScanVal > 135) {
				break;
			}
		}
		//SCAN RIGHT=========================
		//	while (USScanVal >= 116) {
		while(true) {
			servo[servoUSSeeker] = ServoValue[servoUSSeeker] - 5;
			USScanVal -= 5;
			wait1Msec(100);
			if (USScanVal < 40) {
				break;
			}
			if (SensorValue[US1] < kothAttackDistance && nPgmTime < 27000) { //if something is in range AND program time is less than 27 seconds
				PlaySound(soundFastUpwardTones);
				searchingForBot = true;
				turnedLeft = false;
				turnedRight = true;
				turnTowardsRobot();
				pushOffRamp();
				turnTowardsCenter();
			}
		}
	}
}

void turnTowardsRobot() {
	//int tmpUS = USScanVal;
	time1[T2] = 0;

	while(searchingForBot) {
		while (USScanVal > 92 ) {

			wait1Msec(20);

			//if (abs(rotSpeed) > 3) {
			rotSpeed = HTGYROreadRot(HTGYRO);//find gyro rotation speed
			heading += (rotSpeed * 0.02) / 0.2;//find gyro heading in degrees??
			//}

			//PlayTone(400, 500);
			motor[motorLeft] = -5;
			motor[motorRight] = 5;
			if (heading >= USScanVal) {
			    motor[motorLeft] = 0;
			    motor[motorRight] = 0;
				searchingForBot = false;

			}//end if
			break;
		}//end while

		while (USScanVal < 92) {

			wait1Msec(20);

			//if (abs(rotSpeed) > 3) {
			rotSpeed = HTGYROreadRot(HTGYRO);//find gyro rotation speed
			heading += (rotSpeed * 0.02) / 0.3;//find gyro heading in degrees??
			//}

			//PlayTone(400, 500);
			motor[motorLeft] = 5;
			motor[motorRight] = -5;
			if (heading <= USScanVal) {
				motor[motorLeft] = 0;
			  motor[motorRight] = 0;
				searchingForBot = false;

			}//end if
			break;
		}//end while

		if (USScanVal == 92) {
			//do nothing
			break;
		}
	}//end search
}//end void

void turnTowardsCenter() {

	if (turnedLeft) {
		while(heading > 92) {

			wait1Msec(20);

			//if (abs(rotSpeed) > 3) {
			rotSpeed = HTGYROreadRot(HTGYRO);//find gyro rotation speed
			heading += (rotSpeed * 0.02) / 0.2;//find gyro heading in degrees??
			//}

			motor[motorLeft] = 5;
			motor[motorRight] = -5;

			if (heading <= 92) {
				motor[motorLeft] = 0;
				motor[motorRight] = 0;
				break;
			}
		}
		turnedLeft = false;
		turnedRight = false;
	}

	if (turnedRight) {
		while(heading < 92) {

			wait1Msec(20);

			//if (abs(rotSpeed) > 3) {
			rotSpeed = HTGYROreadRot(HTGYRO);//find gyro rotation speed
			heading += (rotSpeed * 0.02) / 0.3;//find gyro heading in degrees??
			//}

			motor[motorLeft] = -5;
			motor[motorRight] = 5;

			if (heading >= 92) {
				motor[motorLeft] = 0;
				motor[motorRight] = 0;
				break;
			}
		}
		turnedLeft = false;
		turnedRight = false;
	}
}

void moveForward(int mtime, int mpower) {
	motor[motorLeft] = -1 *mpower;
	motor[motorRight] = -1 * mpower;
	wait1Msec(mtime * 1000);
	motor[motorLeft] = 0;
	motor[motorRight] = 0;
}

void moveBackward(int mtime, int mpower) {
	motor[motorLeft] = mpower;
	motor[motorRight] = mpower;
	wait1Msec(mtime * 1000);
	motor[motorLeft] = 0;
	motor[motorRight] = 0;
}

void pushOffRamp() {
	moveForward(1.5, 100); //drive forward and backward (make sure this doesnt drive us off the ramp)
	wait1Msec(200);
	moveBackward(1.5, 100);
	wait1Msec(200);
	PlaySound(soundBlip);
}
