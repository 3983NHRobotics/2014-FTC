#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S3,     HTIRS2,         sensorI2CCustom)
#pragma config(Sensor, S4,     US1,            sensorSONAR)
#pragma config(Motor,  motorA,          motorAutoScore, tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motorLeft,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorRight,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorArm,      tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//####################################################################################//
//																																										//
//															2013-2014 Autonomous Code															//
//													  Team 3983 - Highlands Robotics													//
//												  Code by T. Kluge & Music by James H.											//
//																																										//
//####################################################################################//


//referenced files here

#include "joystickdriver.c"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-gyro.h"

//#include "drivers/lego-ultrasound.h"

//variables + functions here

void moveForward(int mtime, int mpower);
void moveBackward(int mtime, int mpower);
void turnLeft(int mtime, int mpower);
void turnRight(int mtime, int mpower);
void scoreCube();
void killall();
void MissionImpossible();
void initializeRobot();
void displayText(int nLineNumber, const string cChar, int nValueDC, int nValueAC);
void displayText3(int nLineNumber, const string cChar, int nValueDC, int nValueAC, int nValueEnh);
void driveToEnd(int distanceToEdge);
bool searching = true;
bool koth = false;
bool goToEnd = true;
int roundTime = 0;
int timeToEnd = 3500;
int kothAttackDistance = 50; //distance in cm (ultrasonic sensor)
int irFindVal = 150; //edit this to match the ultrasonic sensor read value for the correct distance
string sTextLines[8];
string fileName = "IRvals.txt";
int sizeOfFile = 400;
string irvalres = "";
const tMUXSensor HTIRS_L = msensor_S3_1; //Left IRSeeker
const tMUXSensor HTIRS_R = msensor_S3_2; //Right IRSeeker
const tMUXSensor HTACS = msensor_S3_3; //Accel Sensor

task main()
{
	TFileHandle irFileHandle;
	TFileIOResult IOResult;

	PlaySound(soundBlip);
	wait1Msec((2 * PI) * 1000); //TAUUUU
	PlaySound(soundFastUpwardTones);

	//_________________________________BLOCK TO GET SENSORVALUES FROM IRSEEKER_________________________
	//=================================================================================================
	int _dirDC = 0;
	int _dirAC = 0;
	int dcS1, dcS2, dcS3, dcS4, dcS5 = 0;
	int acS1, acS2, acS3, acS4, acS5 = 0;
	int _dirEnh, _strEnh;

	// the default DSP mode is 1200 Hz.

	initializeRobot();
	waitForStart();
	ClearTimer(T1);
	OpenWrite(irFileHandle, IOResult, fileName, sizeOfFile);

	// FULLY DYNAMIC CODE W/ SCORING OF CUBE
	while(searching)
	{

		float irval = acS3;
		StringFormat(irvalres, "%3.0f", irval);

		WriteText(irFileHandle, IOResult, "Test");
		WriteString(irFileHandle, IOResult, irvalres);
		WriteByte(irFileHandle, IOResult, 13);
		WriteByte(irFileHandle, IOResult, 10);


		_dirDC = HTIRS2readDCDir(HTIRS2);
		if (_dirDC < 0)
			break; // I2C read error occurred

		// read the current modulated signal direction
		_dirAC = HTIRS2readACDir(HTIRS2);
		if (_dirAC < 0)
			break; // I2C read error occurred

		// Read the individual signal strengths of the internal sensors
		// Do this for both unmodulated (DC) and modulated signals (AC)
		if (!HTIRS2readAllDCStrength(HTIRS2, dcS1, dcS2, dcS3, dcS4, dcS5))
			break; // I2C read error occurred
		if (!HTIRS2readAllACStrength(HTIRS2, acS1, acS2, acS3, acS4, acS5 ))
			break; // I2C read error occurred

		// Read the Enhanced direction and strength
		if (!HTIRS2readEnhanced(HTIRS2, _dirEnh, _strEnh))
			break; // I2C read error occurred

		//TEST THING FOR RECORDING US BEACON STRENGTH VALUES TO TEXT FILE FOR TESTING (DOES NOT ACTUALLY WORK)
			//^THAT BIT IS SOMEWHERE ELSE NOW

		//______________END SENSORVAL BLOCK________________________________________________________________
		//=================================================================================================

		if (acS3 < irFindVal) { //While sensor is heading towards beacon: acs3 = side
			motor[motorLeft] = -80;
			motor[motorRight] = -80;

			if (time1[T1] > timeToEnd) {
				searching = false;
				koth = true;
				goToEnd = false;
			}
		}

		if (acS3 > irFindVal) { //if sensor is directly in front of beacon
			/* //commented because in competition it doesnt overshoot the beacon
			motor[motorLeft] = 0;
			motor[motorRight] = 0;
			wait1Msec(200);
			motor[motorLeft] = 30;//back up because it overshoots the beacon
			motor[motorRight] = 30;
			wait1Msec(200);
			*/
			motor[motorLeft] = 0;
			motor[motorRight] = 0;

			searching = false;
			koth = true;
			goToEnd = true;
		}
		wait1Msec(30);
	}//while searching

	Close(irFileHandle, IOResult);
	roundTime = time1[T1]; //probably unnecessary, is to cut out the time from the cube scorer
	scoreCube();

	if (goToEnd) {
		driveToEnd(timeToEnd - roundTime);//drive to end of ramp
	}

	wait1Msec(300);
	//turn left, forward, turn left, forward onto ramp
	turnLeft(1.1, 100);
	wait1Msec(300);
	moveForward(1, 100);
	wait1Msec(300);
	turnLeft(1.1, 100);
	wait1Msec(300);
	moveForward(2.7, 100);
	wait1Msec(300);

	//Begin KotH routine

	while (koth) {
		if (SensorValue[US1] < kothAttackDistance && nPgmTime < 27000) { //if something is in range AND program time is less than 27 seconds
			PlaySound(soundFastUpwardTones);
			moveForward(1.5, 100); //drive forward and backward (make sure this doesnt drive us off the ramp)
			wait1Msec(200);
			moveBackward(1.5, 100);

		}

		wait1Msec(200);
		PlaySound(soundBlip);

		if (nPgmTime > 29000) {
			koth = false;
		}
	}//while koth
PlaySound(soundDownwardTones);

}//task main

//Define functions here instead of at the top
void driveToEnd(int distanceToEdge) {
	motor[motorLeft] = -80;
	motor[motorRight] = -80;
	wait1Msec(distanceToEdge);
	motor[motorLeft] = 0;
	motor[motorRight] = 0;
}

void moveForward(int mtime, int mpower) {

	motor[motorLeft] = -1 *mpower;
	motor[motorRight] = -1 * mpower;
	wait1Msec(mtime * 1000);
	motor[motorLeft] = 0;
	motor[motorRight] = 0;

}

void moveBackward(int mtime, int mpower) {

	motor[motorLeft] = mpower;
	motor[motorRight] = mpower;
	wait1Msec(mtime * 1000);
	motor[motorLeft] = 0;
	motor[motorRight] = 0;

}

void turnLeft(int mtime, int mpower) {

	motor[motorLeft] = mpower;
	motor[motorRight] = -1 * mpower;
	wait1Msec(mtime * 1000);
	motor[motorLeft] = 0;
	motor[motorRight] = 0;

}

void turnRight(int mtime, int mpower) {

	motor[motorLeft] = -1 * mpower;
	motor[motorRight] = mpower;
	wait1Msec(mtime * 1000);
	motor[motorLeft] = 0;
	motor[motorRight] = 0;

}

void armLift(int mtime, int mpower) {

	motor[motorArm] = mpower;
	//motor[motorArm2] = mpower;
	wait1Msec(mtime * 1000);
	motor[motorArm] = 0;
	//motor[motorArm2] = 0;

}

void scoreCube() {
	motor[motorAutoScore] = 40;
	wait1Msec(500);
	motor[motorAutoScore] = 0;

	motor[motorAutoScore] = -40;
	wait1Msec(500);
	motor[motorAutoScore] = 0;
}

void killall() {
	motor[motorLeft] = 0;
	motor[motorRight] = 0;
	motor[motorArm] = 0;
	PlaySound(soundException);
	PlaySound(soundDownwardTones);
}

void MissionImpossible()
{
	//        100 = Tempo
	//          6 = Default octave
	//    Quarter = Default note length
	//        10% = Break between notes
	//
	PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	PlayTone(  988,    7); wait1Msec(  75);  // Note(E, Duration(32th))
	PlayTone( 1047,    7); wait1Msec(  75);  // Note(F, Duration(32th))
	PlayTone( 1109,    7); wait1Msec(  75);  // Note(F#, Duration(32th))
	PlayTone( 1175,    7); wait1Msec(  75);  // Note(G, Duration(32th))
	PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	PlayTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	PlayTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))
	PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	PlayTone( 1047,   14); wait1Msec( 150);  // Note(F, Duration(16th))
	PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	PlayTone( 1109,   14); wait1Msec( 150);  // Note(F#, Duration(16th))
	PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	PlayTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	PlayTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))
	PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	PlayTone( 1047,   14); wait1Msec( 150);  // Note(F, Duration(16th))
	PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	PlayTone( 1109,   14); wait1Msec( 150);  // Note(F#, Duration(16th))
	PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	PlayTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	PlayTone(  880,  108); wait1Msec(1200);  // Note(D, Duration(Half))
	PlayTone(    0,    7); wait1Msec(  75);  // Note(Rest, Duration(32th))
	PlayTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	PlayTone(  831,  108); wait1Msec(1200);  // Note(C#, Duration(Half))
	PlayTone(    0,    7); wait1Msec(  75);  // Note(Rest, Duration(32th))
	PlayTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	PlayTone(  784,  108); wait1Msec(1200);  // Note(C, Duration(Half))
	PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	PlayTone(  932,   14); wait1Msec( 150);  // Note(A#5, Duration(16th))
	PlayTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))
	return;
}

void initializeRobot() {
	servo[srvo_S1_C3_1] = 165;
	return;

}

void displayText(int nLineNumber, const string cChar, int nValueDC, int nValueAC)
{
	string sTemp;

	StringFormat(sTemp, "%4d %4d", nValueDC, nValueAC);

	// Check if the new line is the same as the previous one
	// Only update screen if it's different.
	if (sTemp != sTextLines[nLineNumber])
	{
		string sTemp2;

		sTextLines[nLineNumber] = sTemp;
		StringFormat(sTemp2, "%s:%s", cChar, sTemp);
		nxtDisplayTextLine(nLineNumber, sTemp2);
	}
}

void displayText3(int nLineNumber, const string cChar, int nValueDC, int nValueAC, int nValueEnh)
{
	string sTemp;

	StringFormat(sTemp, "%4d %4d %3d", nValueDC, nValueAC, nValueEnh);

	// Check if the new line is the same as the previous one
	// Only update screen if it's different.
	if (sTemp != sTextLines[nLineNumber])
	{
		string sTemp2;

		sTextLines[nLineNumber] = sTemp;
		StringFormat(sTemp2, "%s:%s", cChar, sTemp);
		nxtDisplayTextLine(nLineNumber, sTemp2);
	}
}
