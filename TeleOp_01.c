#pragma config(Hubs,  S2, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     HTIRS2L,        sensorI2CCustom)
#pragma config(Sensor, S3,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S4,     US1,            sensorSONAR)
#pragma config(Motor,  motorA,          motorAutoScore, tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     motorLeft,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     motorWinch,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     motorScoop,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     motorArm,      tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C4_1,     motorRight,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C4_2,     motorLift,     tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S2_C3_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S2_C3_2,    servoUSSeeker,        tServoStandard)
#pragma config(Servo,  srvo_S2_C3_3,    servoLift,            tServoStandard)
#pragma config(Servo,  srvo_S2_C3_4,    servoClamp,           tServoStandard)
#pragma config(Servo,  srvo_S2_C3_5,    servoHook,            tServoStandard)
#pragma config(Servo,  srvo_S2_C3_6,    servoSweep,           tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//####################################################################################//
//
//                                   2013-2014 TeleOp Code
//                               Team 3983 - Highlands Robotics
//                                      Code by T. Kluge
//
//####################################################################################//


#include "JoystickDriver.c"

void scoreCube();

task main()

{
	waitForStart();
	servo[servoHook] = 252;

	while(true) {

		bFloatDuringInactiveMotorPWM = false;
		getJoystickSettings(joystick);
		//Anti-RageQuit code (prevents movement when the joysticks are just a bit off)

		//CONTROLLER 1 JOYSTICK 1 - Drive (Forward/Backward)
		if((joystick.joy1_y1<10&&joystick.joy1_y1>-10)&&(joystick.joy1_x1<10&&joystick.joy1_x1>-10))
		{
			joystick.joy1_y1=0;
			joystick.joy1_x1=0;
		}
		//CONTROLLER 1 JOYSTICK 2 - Drive (Turning)
		if((joystick.joy1_x2<10&&joystick.joy1_x2>-10)&&(joystick.joy1_y2<10&&joystick.joy1_y2>-10))
		{
			joystick.joy1_x2=0;
			joystick.joy1_y2=0;

			//WORM GEAR ARM DRIVE
			//This code is in here now so that it only works if the robot is not currently turning
			//This is to prevent OVing teh batteries and causing a motor lockup

			if (ServoValue[servoSweep] < 198) { //makes sure the sweeper arm is lifted up before the main arm can move
				if (joy2Btn(6)) {									//so that the main arm cannot get stuck on the sweeper arm.
					servo[servoSweep] = 87;//sets the sweeper arm to upward pos just in case
					motor[motorArm] = 100;
					} else if(joy2Btn(8)) {
					servo[servoSweep] = 87;//sets the sweeper arm to upward pos just in case
					motor[motorArm] = -100;
					} else {
					motor[motorArm] = 0;
				}
			}
		}
		//CONTROLLER 2 JOYSTICK 2 - Flag lift motor
		if((joystick.joy2_x2<10&&joystick.joy2_x2>-10)&&(joystick.joy2_y2<10&&joystick.joy2_y2>-10))
		{
			joystick.joy2_x2=0;
			joystick.joy2_y2=0;
		}

		//main drive motor control

		motor[motorLeft] = (joystick.joy1_y1 + joystick.joy1_x2);
		motor[motorRight] = (joystick.joy1_y1 - joystick.joy1_x2);

		motor[motorWinch] = joystick.joy2_y2;
		//motor[motorLift] = joystick.joy2_x2;

		//SWEEPER ARM
		if (joystick.joy2_TopHat == 0 || joy1Btn(7)) { //Joy2TopHat or Joy1 lBumber
			motor[motorScoop] = 100;
			} else if (joystick.joy2_TopHat == 4 || joy1Btn(8)) { //Joy2TopHat or Joy1 rBumper
			motor[motorScoop] = -100;
			} else {
			motor[motorScoop] = 0;
		}

		//WINCH HOOK SERVO
		if (joy2Btn(11)) {
			servo[servoHook] = 35;
		}

		if (joy2Btn(12)) {
			servo[servoHook] = 252;
		}

		//SWEEPER ARM RAISE/LOWER
		if (joystick.joy2_TopHat == 2 || joy1Btn(6)) { //Joy2 bPadRight or Joy1 rBumper
			servo[servoSweep] = 87;//Raised
			motor[motorScoop] = -100;//sets the bevel gears in by spinning sweeper motor
			wait1Msec(300);
			motor[motorScoop] = 0;
			} else if (joystick.joy2_TopHat == 6 || joy1Btn(5)) { //Joy2 bPadLeft or Joy1 lBumper
			servo[servoSweep] = 199;//Lowered
		}

		//SECTION FOR FLAG LIFTER
		if (joy2Btn(1)) { //bPadTop
			servo[servoLift] = 16;
			} else if (joy2Btn(4)) {//bPadBottom
			servo[servoLift] = 123;
			motor[motorLift] = 0;
		}

		//Flag Lifter Motor
		if (joy2Btn(2)) {
			motor[motorLift] = 100;
		} else if (joy2Btn(3)) {
			motor[motorLift] = -100;
		} else {
			motor[motorLift] = 0;
		}

		//Cube Clamp
		if (joy2Btn(5)) {
			servo[servoClamp] = 136;
		} else if (joy2Btn(7)) {
			servo[servoClamp] = 0;
		}

		//TEST THING
		if (bDisconnected) {
			joystick.joy1_y1 = 0;
			joystick.joy1_y2 = 0;
			joystick.joy2_TopHat = -1;
		}

		if (joy2Btn(10)) {
			scoreCube();
		}

		//Anti-jitter
		wait1Msec(10);
	}//end of main while(true)
}//end of task(main)

void scoreCube() {
	motor[motorAutoScore] = 40;
	wait1Msec(500);
	motor[motorAutoScore] = 0;

	motor[motorAutoScore] = -40;
	wait1Msec(500);
	motor[motorAutoScore] = 0;
}
